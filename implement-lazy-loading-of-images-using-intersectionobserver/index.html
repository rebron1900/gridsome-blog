<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>只是玩玩 | JUST FUN - 只是玩玩 | JUST FUN</title><meta name="gridsome:hash" content="0810a28e7848218696784bc8b33ad1e40c9e72dc"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="Hello"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/gridsome-blog/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/gridsome-blog/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/gridsome-blog/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/gridsome-blog/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/gridsome-blog/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/gridsome-blog/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/gridsome-blog/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/gridsome-blog/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link rel="preload" href="/gridsome-blog/assets/css/0.styles.be694e5c.css" as="style"><link rel="preload" href="/gridsome-blog/assets/js/app.ea73c485.js" as="script"><link rel="preload" href="/gridsome-blog/assets/js/page--src--templates--ghost-post-vue.0de93747.js" as="script"><link rel="prefetch" href="/gridsome-blog/assets/js/6.4b802b1d.js"><link rel="prefetch" href="/gridsome-blog/assets/js/page--node-modules--gridsome--app--pages--404-vue.5fb9a6b8.js"><link rel="prefetch" href="/gridsome-blog/assets/js/page--src--pages--index-copy-vue.caed7301.js"><link rel="prefetch" href="/gridsome-blog/assets/js/page--src--pages--index-vue.daf713f0.js"><link rel="stylesheet" href="/gridsome-blog/assets/css/0.styles.be694e5c.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body  class="darkmode">
    <main role="main" data-server-rendered="true" id="app" class="container"><div class="row"><header class="header"><a href="/gridsome-blog/" class="active"><h1>👨‍💻 只是玩玩 | JUST FUN</h1></a><!----></header><div class="article"><h1 class="article-title">利用IntersectionObserver几行代码简单实现图片懒加载</h1><p class="article-date"> 15 June 2023 · <i> min read</i></p><article><p>博客之前集成了<a href="https://1900.live/douban">Douban数据</a>的展示功能，不过由于数据一次性加载过多，且都是有图片的数，导致在进入该网页时会使浏览器卡死3-5秒，等到图片完全加载完毕后才能正常操作，非常影响用户体验。</p><p>我检查了一下，发现卡顿的原因主要还是一次性发起的图片加载请求太多了，查了下资料，似乎下一代的HTTP2.0协议好像对这方面做了优化。但是常规做法还是使用懒加载来处理，也就是滚到图片位置才进行图片请求。</p><p>不过我不太想使用第三方的库来处理这个问题，其他库用起来麻烦，而且很臃肿，我其实只要简单的实现这个功能就好了。之前在移植Smart主题的TOC功能到二〇一九上时发现他使用了 <code>IntersectionObserver</code> 这个函数来处理，便查了一下这个函数的介绍：</p><blockquote>Intersection Observer API 提供了一种异步检测目标元素与祖先元素或 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport?ref=1900.live">viewport</a> 相交情况变化的方法。</blockquote><p>这个函数多用于以下几种情况</p><ul><li>图片懒加载——当图片滚动到可见时才进行加载</li><li>内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉</li><li>检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况</li><li>在用户看见某个区域时执行任务或播放动画</li></ul><p>后查了一些范例，便参照<a href="https://juejin.cn/post/6844903930183303181?ref=1900.live">这个教程</a>的实现了图片的懒加载功能 </p><figure class="kg-card kg-code-card"><pre><code class="language-html">&lt;div class="lazyload-wrapper "&gt;
	&lt;img src="https://iph.href.lu/150x220?text=Loading&amp;fg=666666&amp;bg=cccccc" data-src="{%= o.douban[i].poster %}" referrer-policy="no-referrer" class="lazyload" alt="{%= o.douban[i].title %}" width="150" height="220"&gt;
&lt;/div&gt;</code></pre><figcaption>处理图片src</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-js">      let images = document.querySelectorAll(".lazyload");
      let observer = new IntersectionObserver(entries =&gt; {
        entries.forEach(item =&gt; {
          if (item.isIntersecting) {
            item.target.src = item.target.dataset.src; // 开始加载图片,把data-src的值放到src
            observer.unobserve(item.target); // 停止监听已开始加载的图片
          }
        });
      },
        {
          rootMargin: "0px 0px 500px 0px" // 交叉视图前的500像素时，就开始派发事件
        }
      );
      images.forEach(item =&gt; observer.observe(item));</code></pre><figcaption>js实现主体</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn.1900.live/assets/2023/06/15image.png" class="kg-image" alt loading="lazy" width="524" height="397"><figcaption>rootMargin示例</figcaption></figure><p>原理其实很简单</p><ul><li>先修改你的所有图片，将img元素的src属性指定为空或者一个展位图，然后添加的一个data属性存放图片链接，如 <code>data-src</code> ，添加 <code>lazyload</code> 类用于之后可以获取到图片。</li><li>通过之前设置的类名获取所有需要懒加载的图片元素。</li><li>创建一个IntersectionObserver对象，并传入一个处理函数和rootMagin</li><li>处理函数的主要内容是检测被观测到的对象的 <code>isIntersecting</code>(如果 <code>isIntersecting</code> 为真，则该图片至少已经达到我们设置的rootMargin值以内)<strong> </strong>判断，如果进入了目标区间内则将img的data-src设置为src属性。</li><li>并通过调用 <code>unobserve</code> 停止对这个片检测。</li></ul><p>我记得以前实现起来挺复杂的，现在有了个函数只需要简单的几行代码就可以实现，真的方便。</p><p>END</p><div class="kg-card kg-callout-card kg-callout-card-blue"><div class="kg-callout-emoji">🥳</div><div class="kg-callout-text">后续：主题修改完上传到服务器后发现还是会出现卡死的情况，通过使用Chrome的性能工具发现pangu.autoSpacingPage()阻塞了进程...。</div></div><div class="kg-card kg-callout-card kg-callout-card-red"><div class="kg-callout-emoji">🥳</div><div class="kg-callout-text">后续2：根据「剑公子 」的留言，现代浏览器已经<a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/Lazy_loading?ref=1900.live">原生支持懒加载</a>，只需要在img标签中添加属性 <code>loading="lazy"</code> 即可。</div></div><p>通过性能检测工具可以发现 <code>spacingNode</code> 、 <code>spacingNodeByXPath</code> 阻塞了进程，不知道是什么原因。我尝试将调用函数换成 <code>spacingPageBody()</code> 后页面性能恢复正常。可能是body之外的某些标签阻塞了函数执行。</p><figure class="kg-card kg-image-card"><img src="https://cdn.1900.live/assets/2023/06/151a114653-96f2-4329-9389-6990e82b8050.png" class="kg-image" alt loading="lazy" width="1050" height="969"></figure></article></div><div class="footer"><div><p>
          Built with
          <a target="_blank" href="//gridsome.org" class="link">Gridsome</a>
          &amp; Made with ❤️ by
          <a target="_blank" href="//alex.design" class="link">Alex Brown</a></p></div><div class="footer-links"><a target="_blank" href="/sitemap.xml">Sitemap</a><a target="_blank" href="/feed.xml">RSS Feed</a></div></div></div></main>
    <script>window.__INITIAL_STATE__={"data":{"metadata":{"siteName":"只是玩玩 | JUST FUN","siteDescription":"Hello"},"post":{"id":"648a82a1b7445300017623ac","title":"利用IntersectionObserver几行代码简单实现图片懒加载","content":"\u003Cp\u003E博客之前集成了\u003Ca href=\"https:\u002F\u002F1900.live\u002Fdouban\"\u003EDouban数据\u003C\u002Fa\u003E的展示功能，不过由于数据一次性加载过多，且都是有图片的数，导致在进入该网页时会使浏览器卡死3-5秒，等到图片完全加载完毕后才能正常操作，非常影响用户体验。\u003C\u002Fp\u003E\u003Cp\u003E我检查了一下，发现卡顿的原因主要还是一次性发起的图片加载请求太多了，查了下资料，似乎下一代的HTTP2.0协议好像对这方面做了优化。但是常规做法还是使用懒加载来处理，也就是滚到图片位置才进行图片请求。\u003C\u002Fp\u003E\u003Cp\u003E不过我不太想使用第三方的库来处理这个问题，其他库用起来麻烦，而且很臃肿，我其实只要简单的实现这个功能就好了。之前在移植Smart主题的TOC功能到二〇一九上时发现他使用了 \u003Ccode\u003EIntersectionObserver\u003C\u002Fcode\u003E 这个函数来处理，便查了一下这个函数的介绍：\u003C\u002Fp\u003E\u003Cblockquote\u003EIntersection Observer API 提供了一种异步检测目标元素与祖先元素或 \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FGlossary\u002FViewport?ref=1900.live\"\u003Eviewport\u003C\u002Fa\u003E 相交情况变化的方法。\u003C\u002Fblockquote\u003E\u003Cp\u003E这个函数多用于以下几种情况\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E图片懒加载——当图片滚动到可见时才进行加载\u003C\u002Fli\u003E\u003Cli\u003E内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉\u003C\u002Fli\u003E\u003Cli\u003E检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况\u003C\u002Fli\u003E\u003Cli\u003E在用户看见某个区域时执行任务或播放动画\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E后查了一些范例，便参照\u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F6844903930183303181?ref=1900.live\"\u003E这个教程\u003C\u002Fa\u003E的实现了图片的懒加载功能 \u003C\u002Fp\u003E\u003Cfigure class=\"kg-card kg-code-card\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E&lt;div class=\"lazyload-wrapper \"&gt;\n\t&lt;img src=\"https:\u002F\u002Fiph.href.lu\u002F150x220?text=Loading&amp;fg=666666&amp;bg=cccccc\" data-src=\"{%= o.douban[i].poster %}\" referrer-policy=\"no-referrer\" class=\"lazyload\" alt=\"{%= o.douban[i].title %}\" width=\"150\" height=\"220\"&gt;\n&lt;\u002Fdiv&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cfigcaption\u003E处理图片src\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cfigure class=\"kg-card kg-code-card\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E      let images = document.querySelectorAll(\".lazyload\");\n      let observer = new IntersectionObserver(entries =&gt; {\n        entries.forEach(item =&gt; {\n          if (item.isIntersecting) {\n            item.target.src = item.target.dataset.src; \u002F\u002F 开始加载图片,把data-src的值放到src\n            observer.unobserve(item.target); \u002F\u002F 停止监听已开始加载的图片\n          }\n        });\n      },\n        {\n          rootMargin: \"0px 0px 500px 0px\" \u002F\u002F 交叉视图前的500像素时，就开始派发事件\n        }\n      );\n      images.forEach(item =&gt; observer.observe(item));\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cfigcaption\u003Ejs实现主体\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cfigure class=\"kg-card kg-image-card kg-card-hascaption\"\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.1900.live\u002Fassets\u002F2023\u002F06\u002F15image.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"524\" height=\"397\"\u003E\u003Cfigcaption\u003ErootMargin示例\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E原理其实很简单\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E先修改你的所有图片，将img元素的src属性指定为空或者一个展位图，然后添加的一个data属性存放图片链接，如 \u003Ccode\u003Edata-src\u003C\u002Fcode\u003E ，添加 \u003Ccode\u003Elazyload\u003C\u002Fcode\u003E 类用于之后可以获取到图片。\u003C\u002Fli\u003E\u003Cli\u003E通过之前设置的类名获取所有需要懒加载的图片元素。\u003C\u002Fli\u003E\u003Cli\u003E创建一个IntersectionObserver对象，并传入一个处理函数和rootMagin\u003C\u002Fli\u003E\u003Cli\u003E处理函数的主要内容是检测被观测到的对象的 \u003Ccode\u003EisIntersecting\u003C\u002Fcode\u003E(如果 \u003Ccode\u003EisIntersecting\u003C\u002Fcode\u003E 为真，则该图片至少已经达到我们设置的rootMargin值以内)\u003Cstrong\u003E \u003C\u002Fstrong\u003E判断，如果进入了目标区间内则将img的data-src设置为src属性。\u003C\u002Fli\u003E\u003Cli\u003E并通过调用 \u003Ccode\u003Eunobserve\u003C\u002Fcode\u003E 停止对这个片检测。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E我记得以前实现起来挺复杂的，现在有了个函数只需要简单的几行代码就可以实现，真的方便。\u003C\u002Fp\u003E\u003Cp\u003EEND\u003C\u002Fp\u003E\u003Cdiv class=\"kg-card kg-callout-card kg-callout-card-blue\"\u003E\u003Cdiv class=\"kg-callout-emoji\"\u003E🥳\u003C\u002Fdiv\u003E\u003Cdiv class=\"kg-callout-text\"\u003E后续：主题修改完上传到服务器后发现还是会出现卡死的情况，通过使用Chrome的性能工具发现pangu.autoSpacingPage()阻塞了进程...。\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cdiv class=\"kg-card kg-callout-card kg-callout-card-red\"\u003E\u003Cdiv class=\"kg-callout-emoji\"\u003E🥳\u003C\u002Fdiv\u003E\u003Cdiv class=\"kg-callout-text\"\u003E后续2：根据「剑公子 」的留言，现代浏览器已经\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FWeb\u002FPerformance\u002FLazy_loading?ref=1900.live\"\u003E原生支持懒加载\u003C\u002Fa\u003E，只需要在img标签中添加属性 \u003Ccode\u003Eloading=\"lazy\"\u003C\u002Fcode\u003E 即可。\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E通过性能检测工具可以发现 \u003Ccode\u003EspacingNode\u003C\u002Fcode\u003E 、 \u003Ccode\u003EspacingNodeByXPath\u003C\u002Fcode\u003E 阻塞了进程，不知道是什么原因。我尝试将调用函数换成 \u003Ccode\u003EspacingPageBody()\u003C\u002Fcode\u003E 后页面性能恢复正常。可能是body之外的某些标签阻塞了函数执行。\u003C\u002Fp\u003E\u003Cfigure class=\"kg-card kg-image-card\"\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.1900.live\u002Fassets\u002F2023\u002F06\u002F151a114653-96f2-4329-9389-6990e82b8050.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1050\" height=\"969\"\u003E\u003C\u002Ffigure\u003E","date":"15 June 2023","path":"implement-lazy-loading-of-images-using-intersectionobserver"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/gridsome-blog/assets/js/app.ea73c485.js" defer></script><script src="/gridsome-blog/assets/js/page--src--templates--ghost-post-vue.0de93747.js" defer></script>
  </body>
</html>