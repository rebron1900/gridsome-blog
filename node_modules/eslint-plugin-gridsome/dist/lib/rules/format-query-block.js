"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const utils_1 = require("../utils");
const prettier_1 = __importDefault(require("prettier"));
const prettierParser = "graphql";
const LINES = /[^\r\n\u2028\u2029]+(?:$|\r\n|[\r\n\u2028\u2029])|\s/gu;
const defaultOptions = [{}];
module.exports = utils_1.createRule({
    name: "format-query-block",
    meta: {
        docs: {
            description: "Format fix for `<page-query>` and `<static-query>` in .vue. Using Prettier API",
            category: "Stylistic Issues",
            recommended: false,
        },
        type: "layout",
        fixable: "whitespace",
        messages: {
            formatQueryBlock: "{{ name }} code format is incorrect",
        },
        schema: [
            {
                type: "object",
                properties: {
                    overridePrettierOption: {
                        type: "object",
                        items: [
                            { tabWidth: "number" },
                            { useTabs: "boolean" },
                            { vueIndentScriptAndStyle: "boolean" },
                        ],
                    },
                },
            },
        ],
    },
    defaultOptions,
    create(context) {
        var _a;
        const overridePrettierOption = (_a = context.options[0]) === null || _a === void 0 ? void 0 : _a.overridePrettierOption;
        const sourceCode = context.getSourceCode();
        const filePath = context.getFilename();
        const mergedPrettierOption = utils_1.getMergedPrettierOption(utils_1.getPrettierDefaultOption, utils_1.getPrettierRcOption(filePath));
        const { indentRepeatTime, indentChar } = utils_1.getCodeWrapIndentInfo(mergedPrettierOption, overridePrettierOption);
        const indent = indentChar.repeat(indentRepeatTime);
        return {
            Program(node) {
                if (!node.templateBody) {
                    return;
                }
                const topLevelNodes = node.templateBody.parent.children;
                for (const topLevelNode of topLevelNodes) {
                    if (topLevelNode.type === "VElement" &&
                        (topLevelNode.name === utils_1.NodeNames["page-query"] ||
                            topLevelNode.name === utils_1.NodeNames["static-query"])) {
                        const codeRange = [
                            topLevelNode.startTag.range[1],
                            topLevelNode.endTag
                                ? topLevelNode.endTag.range[0]
                                : topLevelNode.range[1],
                        ];
                        const code = sourceCode.text.slice(...codeRange);
                        const prettierConfig = Object.assign(Object.assign({}, utils_1.getPrettierRcOption(filePath)), overridePrettierOption);
                        const formattedCode = prettier_1.default
                            .format(code, Object.assign(Object.assign({}, prettierConfig), { parser: prettierParser }))
                            .trim();
                        let lines = formattedCode.match(LINES);
                        if (lines === null) {
                            return;
                        }
                        lines = ["\n", ...lines, "\n"];
                        const wrappedIndentCode = lines
                            .map((line) => {
                            if (line === "\n") {
                                return line;
                            }
                            return indent + line;
                        })
                            .join("");
                        if (wrappedIndentCode !== code) {
                            context.report({
                                messageId: "formatQueryBlock",
                                data: {
                                    name: topLevelNode.name,
                                },
                                node: topLevelNode,
                                loc: topLevelNode.loc,
                                fix(fixer) {
                                    return fixer.replaceTextRange(codeRange, wrappedIndentCode);
                                },
                            });
                        }
                    }
                }
            },
        };
    },
});
