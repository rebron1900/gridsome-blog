{"hash":"79ad4906a93b028ce0cc44a61d77049cbbf31c8d","data":{"metadata":{"siteName":"只是玩玩 | JUST FUN","siteDescription":"Hello"},"post":{"id":"63158312cf533d1c2cf29b3b","title":"Godot游戏引擎学习 第六课","content":"<!--kg-card-begin: markdown--><p>今天学的是如何添加怪物，并让怪物移动。</p>\n<p>这节课UP讲了好几个方面的东西，有点杂，我这里根据个人理解做点学习笔记。</p>\n<h2 id>一、 怪物对象化</h2>\n<p>怪物是有很多种类的，而且怪物具有很多相同过的特性和不同的特性。为了以后好开发将一些共有属性提取出来做个父类是很有必要的。</p>\n<p>这里UP就讲了一个继承脚本、场景的的东西，</p>\n<p>先建立一个Enemy场景，设定一些共有节点</p>\n<p><img src=\"https://cdn.1900.live/typora/image-20201224210915823.png\" alt=\"image-20201224210915823\" loading=\"lazy\"></p>\n<p>建立对应的脚本，独立出共有属性</p>\n<pre><code class=\"language-python\">extends KinematicBody2D\n\n# 共有属性重力\nconst gravity = 2000\n# 因为要处理精灵方向的问题，所以做个预载变量。\nonready var sprite: Sprite = $Sprite\n\n</code></pre>\n<p>然后点击编辑器菜单上的场景按钮，选择建立继承场景，父场景选择<code>Enemy.tscn</code>，就会实例化出一个具有父场景所有属性的子场景，命名为<code>Slime.tscn</code>。然后在这个里面设置Slime的特有属性，如碰撞体、精灵等。</p>\n<p>脚本也同理，选中父节点，按右键选择<code>打开脚本</code>，UP住说这是一个翻译错误，弹幕里也有大佬说<code>这里术语原文是 Extend，呼应脚本里的 extends 关键词</code>,我的理解其实就是父类脚本。新建好的脚本如下，代码我都写了备注就不在这里说了：</p>\n<pre><code class=\"language-python\">extends &quot;res://src/enemies/Enemy.gd&quot;\n\n# 定义枚举，用于指定怪物朝向\nenum Direction { Left = -1, Right = 1 }\n\n# 定义移动速度和加速度，这个其实可以提取出来到父脚本去\nconst max_speed = 50\nconst acceleration = max_speed / 2\n\n# 这里用到一个新东西：export变量，\n# 一个变量加上export就成为外部变量了，可以通过编辑器设置他的值\n# 括号里是指定这个变量的展示类型为上面设置的枚举\nexport(Direction) var direction = Direction.Left\n# 速度\nvar velocity = Vector2.ZERO\n\nfunc _physics_process(_delta):\n\t# 每一个物理帧检查怪物是不是碰到墙了\n\tvar was_on_wall = is_on_wall()\n\t# 怪物不会跳，所以把他们吸附在地板上\n\tvar snap = Vector2.DOWN * 16\n\t# 进行移动操作\n\tvelocity = move_and_slide_with_snap(velocity, snap, Vector2.UP)\n\n\t# 如果碰到墙就转身\n\tif is_on_wall() and not was_on_wall:\n\t\tdirection *= -1\n\n\nfunc _process(delta):\n\t# 进行加速移动\n\tvelocity.x = move_toward(velocity.x, max_speed * direction, acceleration * delta)\n\tvelocity.y += gravity * delta\n\n\t# 进行转身\n\tsprite.flip_h = velocity.x &gt; 0\n\t\n\n</code></pre>\n<p>这里UP主还说了一个BUG，就是在更改了父场景的层归属后子场景不会更新，实例化出来的场景也不会更新，要把主场景关掉后重开就正常了。</p>\n<hr>\n<p>说到精灵这里插一下，有些精灵素材是整合在一起的，所以整个图片会很大，像下图这样，所以我们设置好精灵素材后，启用<code>Region</code>，然后可以先设置<code>Scale</code>把图片缩放到合适的大小，再设置v和hframes，开启网格吸附，将步长设置成每一帧图片的大小，再框选图片就好了。</p>\n<p><img src=\"https://cdn.1900.live/typora/image-20201224211435566.png\" alt=\"image-20201224211435566\" loading=\"lazy\"></p>\n<hr>\n<p>好了，建立好怪物之后就可以实例化到场景里UP又说了昨天碰撞层的问题，现在状态是怪物碰到玩家就不动了，他想让怪物穿过玩家，所以，我们再命名一个怪物层，把实例化的Slime的碰撞和遮罩层分配到这个里面。</p>\n<p>这样因为玩家和怪物不在一个层，所以碰不到怪物，但是怪物们再一个层，他们会互相碰撞。</p>\n<p><img src=\"https://cdn.1900.live/typora/image-20201224213251529.png\" alt=\"image-20201224213251529\" loading=\"lazy\"></p>\n<h2 id>怪物笼</h2>\n<p>其实就是怪物刷新点啦，让怪物定时刷新的功能。</p>\n<p><img src=\"https://cdn.1900.live/typora/%E7%AC%AC%E5%85%AD%E8%AF%BE_%E6%80%AA%E7%89%A9%E7%AC%BC.gif\" alt=\"第六课 怪物笼\" loading=\"lazy\"></p>\n<p>我们可以利用<code>Position2D</code>的和<code>Timer</code>节点实现怪物笼效果，第一个用于定位怪物刷新出来的位置，第二个控制多常时间刷新。</p>\n<p>(这里说下，所有的信号时间必须在编辑器里注册，不然直接写进代码是没有效果的，我前几天说的那个可以手动写信号的话暂时先放一边，目前了解到的暂时不可以)</p>\n<p>代码如下：</p>\n<pre><code class=\"language-python\">extends Position2D\n\n# 让外部可以设置打包场景\nexport var enemy_scene: PackedScene\n# 刷新速度\nexport var interval = 1.0\n\n#定时器\nonready var timer =$Timer\n\nfunc _ready():\n\t# 如果设置了打包场景\n\tif enemy_scene:\n\t\t# 开始计时\n\t\ttimer.start(interval)\n\n# 每进行一次循环完毕的信号\nfunc _on_Timer_timeout():\n\t# 根据设置的打包场景实例化新的怪物对象\n\tvar enemy: Node2D = enemy_scene.instance()\n\t# 将实例化后的怪物添加到父节点中\n\tget_parent().add_child(enemy)\n\t#并将位置设置为Position的节点\n\tenemy.global_position = global_position;\n</code></pre>\n<h2 id>信号的使用和攻击、受伤、攻击特效</h2>\n<p>这里UP提出了攻击盒子和伤害盒子的概念，我因为不太理解的缘故中间代码和设置都整错了一部分，一直不太对，最后把添加的相关场景和代码全部删掉之后重写才正常实现。</p>\n<p>攻击盒子和伤害盒子和场景内角色和怪物都有的一个特性，所以为了复用代码就单独做了两个场景，<code>Hitbox</code>,<code>Hurtbox</code>，</p>\n<p>这里我看的时候理解混乱了好一会儿，后来算是明白了，其实一个攻击或受伤的步骤分为两步，比如攻击</p>\n<ol>\n<li>我感觉到我打到你了</li>\n<li>你感受到我打到你了，你叫了出来。</li>\n</ol>\n<p>其实理解后就很简单了，我的攻击碰到了你的受伤盒子，触发信号，我先执行攻击你的函数，再通知你受伤的信号，执行受伤的函数。</p>\n<p>这里制作了踩中怪物是的攻击特效和怪物的受伤特效</p>\n<pre><code class=\"language-python\"># Player.gd &gt; 省略前面的代码\n# 如果被怪物攻击了，怪物那边的攻击函数就会调用角色的受伤信号\nfunc _on_Hurtbox_hurt():\n\t# 重新加载当前场景。\n\tget_tree().reload_current_scene()\n\n# 如果踩中敌人了则自己处理自己的攻击过程，并通知对方受伤了。\nfunc _on_Hitbox_hit():\n\tvelocity.y = -jump_force / 2\n\t\n# Enemy.gd &gt; 省略了一部分代码\n# 编写信号链接函数\nfunc _on_Hurtbox_area_entered(hitbox):\n    # 如果检测到碰着，也就是受伤\n    # 首先调用受伤的信号\n    emit_signal(&quot;hurt&quot;)\n    # 再调用攻击信号\n    hitbox.emit_signal(&quot;hit&quot;)\n</code></pre>\n<p>大概就是这样把，感觉自己也没讲的很明白。</p>\n<p>总体代码如下：</p>\n<pre><code class=\"language-python\">extends Area2D\n\n# 自定义攻击信号，方便实例后调用\nsignal hit\n\n# 检测攻击状态\nfunc _on_Hitbox_area_entered(hurtbox):\n    # 攻击到敌人先调用攻击信号\n    emit_signal(&quot;hit&quot;)\n    # 再调用对方的受伤信号\n    hurtbox.emit_signal(&quot;hurt&quot;)\n</code></pre>\n<pre><code class=\"language-python\">extends Area2D\n\n# 自定义受伤信号，用于实例化调用\nsignal hurt\n\n# 编写信号链接函数\nfunc _on_Hurtbox_area_entered(hitbox):\n    # 如果检测到碰着，也就是受伤\n    # 首先调用受伤的信号\n    emit_signal(&quot;hurt&quot;)\n    # 再调用攻击信号\n    hitbox.emit_signal(&quot;hit&quot;)\n</code></pre>\n<h2 id>学习成果</h2>\n<p><img src=\"https://cdn.1900.live/typora/%E7%AC%AC%E5%85%AD%E8%AF%BE_ALL.gif\" alt=\"第六课 ALL\" loading=\"lazy\"></p>\n<!--kg-card-end: markdown-->","date":"24 December 2020","path":"godot_learn_lesson_6_game_engine"}},"context":{}}