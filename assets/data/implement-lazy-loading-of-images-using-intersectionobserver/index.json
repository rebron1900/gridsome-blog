{"hash":"79ad4906a93b028ce0cc44a61d77049cbbf31c8d","data":{"metadata":{"siteName":"只是玩玩 | JUST FUN","siteDescription":"Hello"},"post":{"id":"648a82a1b7445300017623ac","title":"利用IntersectionObserver几行代码简单实现图片懒加载","content":"<p>博客之前集成了<a href=\"https://1900.live/douban\">Douban数据</a>的展示功能，不过由于数据一次性加载过多，且都是有图片的数，导致在进入该网页时会使浏览器卡死3-5秒，等到图片完全加载完毕后才能正常操作，非常影响用户体验。</p><p>我检查了一下，发现卡顿的原因主要还是一次性发起的图片加载请求太多了，查了下资料，似乎下一代的HTTP2.0协议好像对这方面做了优化。但是常规做法还是使用懒加载来处理，也就是滚到图片位置才进行图片请求。</p><p>不过我不太想使用第三方的库来处理这个问题，其他库用起来麻烦，而且很臃肿，我其实只要简单的实现这个功能就好了。之前在移植Smart主题的TOC功能到二〇一九上时发现他使用了 <code>IntersectionObserver</code> 这个函数来处理，便查了一下这个函数的介绍：</p><blockquote>Intersection Observer API 提供了一种异步检测目标元素与祖先元素或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport?ref=1900.live\">viewport</a> 相交情况变化的方法。</blockquote><p>这个函数多用于以下几种情况</p><ul><li>图片懒加载——当图片滚动到可见时才进行加载</li><li>内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉</li><li>检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况</li><li>在用户看见某个区域时执行任务或播放动画</li></ul><p>后查了一些范例，便参照<a href=\"https://juejin.cn/post/6844903930183303181?ref=1900.live\">这个教程</a>的实现了图片的懒加载功能 </p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-html\">&lt;div class=\"lazyload-wrapper \"&gt;\n\t&lt;img src=\"https://iph.href.lu/150x220?text=Loading&amp;fg=666666&amp;bg=cccccc\" data-src=\"{%= o.douban[i].poster %}\" referrer-policy=\"no-referrer\" class=\"lazyload\" alt=\"{%= o.douban[i].title %}\" width=\"150\" height=\"220\"&gt;\n&lt;/div&gt;</code></pre><figcaption>处理图片src</figcaption></figure><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-js\">      let images = document.querySelectorAll(\".lazyload\");\n      let observer = new IntersectionObserver(entries =&gt; {\n        entries.forEach(item =&gt; {\n          if (item.isIntersecting) {\n            item.target.src = item.target.dataset.src; // 开始加载图片,把data-src的值放到src\n            observer.unobserve(item.target); // 停止监听已开始加载的图片\n          }\n        });\n      },\n        {\n          rootMargin: \"0px 0px 500px 0px\" // 交叉视图前的500像素时，就开始派发事件\n        }\n      );\n      images.forEach(item =&gt; observer.observe(item));</code></pre><figcaption>js实现主体</figcaption></figure><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.1900.live/assets/2023/06/15image.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"524\" height=\"397\"><figcaption>rootMargin示例</figcaption></figure><p>原理其实很简单</p><ul><li>先修改你的所有图片，将img元素的src属性指定为空或者一个展位图，然后添加的一个data属性存放图片链接，如 <code>data-src</code> ，添加 <code>lazyload</code> 类用于之后可以获取到图片。</li><li>通过之前设置的类名获取所有需要懒加载的图片元素。</li><li>创建一个IntersectionObserver对象，并传入一个处理函数和rootMagin</li><li>处理函数的主要内容是检测被观测到的对象的 <code>isIntersecting</code>(如果 <code>isIntersecting</code> 为真，则该图片至少已经达到我们设置的rootMargin值以内)<strong> </strong>判断，如果进入了目标区间内则将img的data-src设置为src属性。</li><li>并通过调用 <code>unobserve</code> 停止对这个片检测。</li></ul><p>我记得以前实现起来挺复杂的，现在有了个函数只需要简单的几行代码就可以实现，真的方便。</p><p>END</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">🥳</div><div class=\"kg-callout-text\">后续：主题修改完上传到服务器后发现还是会出现卡死的情况，通过使用Chrome的性能工具发现pangu.autoSpacingPage()阻塞了进程...。</div></div><div class=\"kg-card kg-callout-card kg-callout-card-red\"><div class=\"kg-callout-emoji\">🥳</div><div class=\"kg-callout-text\">后续2：根据「剑公子 」的留言，现代浏览器已经<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Performance/Lazy_loading?ref=1900.live\">原生支持懒加载</a>，只需要在img标签中添加属性 <code>loading=\"lazy\"</code> 即可。</div></div><p>通过性能检测工具可以发现 <code>spacingNode</code> 、 <code>spacingNodeByXPath</code> 阻塞了进程，不知道是什么原因。我尝试将调用函数换成 <code>spacingPageBody()</code> 后页面性能恢复正常。可能是body之外的某些标签阻塞了函数执行。</p><figure class=\"kg-card kg-image-card\"><img src=\"https://cdn.1900.live/assets/2023/06/151a114653-96f2-4329-9389-6990e82b8050.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1050\" height=\"969\"></figure>","date":"15 June 2023","path":"implement-lazy-loading-of-images-using-intersectionobserver"}},"context":{}}